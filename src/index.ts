/* eslint-disable import/no-extraneous-dependencies */
import fs from 'node:fs'
import path = require('path')
import { join } from 'node:path'
import readline from 'node:readline'

import * as core from '@actions/core'
import { Octokit } from '@octokit/core'
import fetch from 'node-fetch'
import parseGithubUrl from 'parse-github-url'

const DEFAULT_RISK_LEVEL = 'Low'
const DEFAULT_VERIFICATION = 'SOUP analysed and accepted by developer'
const DEFAULT_SOUP_FILENAME = 'SOUP.md'

type TPackageJson = {
  name: string
  dependencies?: { [key: string]: string }
}

type TNpmData =
  | {
      versions: {
        [key: string]: {
          homepage: string
          repository: {
            url: string
          }
        }
      }
    }
  | undefined

type TSoupData = {
  soupName: string
  soupLanguages: string
  soupSite: string
  soupVersion: string
  soupRiskLevel: string
  soupVerification: string
}

readline.createInterface({
  input: process.stdin,
  output: process.stdout,
})

const auth = core.getInput('token')
const octokit = new Octokit({ auth })

/**
 * Method to request programming language data from GitHub so we can list the language of the SOUP
 * @param soupRepoUrl string: github repo url retrieved from NPM info
 * @returns string: comma separated languages that make up at least 10% of the project
 */
const getSoupLanguageData = async (soupRepoUrl: string) => {
  const { owner, name } = parseGithubUrl(soupRepoUrl) ?? {}
  if (!owner || !name) return 'unknown'

  const soupLanguagesGitHubResponse = await octokit.request(
    'GET /repos/{owner}/{name}/languages',
    { owner, name }
  )

  if (soupLanguagesGitHubResponse.status !== 200) return 'unknown'
  const soupLanguagesData = soupLanguagesGitHubResponse.data as Record<
    string,
    number
  >

  const totalSoupBytes =
    Object.values(soupLanguagesData)?.reduce((a, b) => a + b, 0) ?? 0

  return Object.keys(soupLanguagesData)
    .filter(
      // By filtering out languages that make up less than 10% we prevent listing unrelevant tool languages etc.
      (language) => soupLanguagesData[language] > totalSoupBytes * 0.1
    )
    .join(', ')
}

/**
 * Method to request SOUP package information from NPM
 * @param soupName string: name of the SOUP as listed in our package file
 * @param soupVersion string: version of the SOUP as listed in our lockfile
 */
const getSoupDataForPackage = async (
  soupName: string,
  soupVersion: string
): Promise<TSoupData> => {
  const soupDataResponse = await fetch(`https://registry.npmjs.org/${soupName}`)
  const soupData = (await soupDataResponse.json()) as TNpmData

  let soupLanguages = 'unknown'
  let soupSite = 'private repo'

  if (soupData?.versions) {
    const versionSpecificSoupData =
      soupData?.versions[soupVersion.replaceAll(/[^\d.-]/g, '')]

    if (versionSpecificSoupData?.repository?.url?.includes('github')) {
      soupLanguages = await getSoupLanguageData(
        versionSpecificSoupData.repository.url
      )
    }

    soupSite =
      versionSpecificSoupData?.homepage ||
      versionSpecificSoupData?.repository?.url ||
      'unknown'
  }

  return {
    soupName,
    soupLanguages,
    soupSite,
    soupVersion,
    soupRiskLevel: DEFAULT_RISK_LEVEL,
    soupVerification: DEFAULT_VERIFICATION,
  }
}

/**
 * Method to format SOUP data for one package as a table
 * @param soupData TSoupData: the data generated by the other methods
 */
const generateSoupTable = (soupData: TSoupData[]) => {
  const tableHeader =
    '| Package Name | Programming Languages | Website | Version | Risk Level | Verification of Reasoning |\n|---|---|---|---|---|---|\n'
  const tableContents: string[] = []
  soupData.forEach((data) => {
    tableContents.push(
      `| ${data.soupName} | ${data.soupLanguages} | ${data.soupSite} | ${data.soupVersion} | ${data.soupRiskLevel} | ${data.soupVerification} |`
    )
  })
  return tableHeader + tableContents.sort().join('\n')
}

/**
 * Method to recursively go though all of the repo to find all "package.json" files
 * that might be part of the (mono)repo project
 * @param directory string: the directory to start/continue the recursive search in
 * @param resultArray string[]: the array we pass through recursively and fill with all results
 */
const findFilesRecursive = (directory: string, resultArray: string[]) => {
  fs.readdirSync(directory).forEach((file: string) => {
    const subpath = path.join(directory, file)
    if (fs.lstatSync(subpath).isDirectory()) {
      // Skip node_modules folder
      if (subpath.includes('node_modules')) return
      // don't try to find package.json files in folders like .git or .github
      if (subpath.includes('/.')) return
      findFilesRecursive(subpath, resultArray)
    } else if (file === 'package.json') {
      resultArray.push(`${directory}/${file}`)
    }
  })
}

/**
 * Method to generate a SOUP table for a single package.json. Most repositories will only call this method once
 * But in mono-repos this will be called once for each package.json file in the subfolders of the repo
 * (excluding node_modules)
 * @param packageJSON TPackageJson: the contents of a single package JSON to generate a SOUP table for
 */
const getSoupDataForPackageCollection = async (packageJSON: TPackageJson) => {
  const soupDataRequests = <Promise<TSoupData>[]>[]

  if (packageJSON.dependencies) {
    Object.entries(packageJSON.dependencies).forEach(
      ([soupName, soupVersion]) =>
        soupDataRequests.push(getSoupDataForPackage(soupName, soupVersion))
    )
  }

  const soupData = await Promise.all(soupDataRequests)

  const header = `## ${packageJSON.name}\n\n`
  const table = generateSoupTable(soupData)

  return header + table
}

/**
 * Main generator method: calls the other methods and combines their output in MD format and stores it in SOUP.md
 */
const generateSoupRegister = async () => {
  core.info(`üìã Starting SOUP generation`)

  const basePath = core.getInput('path')
  const rootPath = join(process.cwd(), basePath)
  const soupPath = join(rootPath, DEFAULT_SOUP_FILENAME)

  // get array of package.json paths
  const packageJSONPaths: string[] = []
  findFilesRecursive(rootPath, packageJSONPaths)

  // Read SOUP dependencies from package json
  const packageJSONs = packageJSONPaths
    .map((packageJSONPath) => {
      const packageString = fs.readFileSync(packageJSONPath).toString()
      const packageJSON = JSON.parse(packageString) as TPackageJson
      return packageJSON
    })
    // filter out package.json files without dependencies
    .filter((packageJSON) => !!packageJSON.dependencies)

  const repositorySoupRequests = <Promise<string>[]>[]

  packageJSONs.forEach((packageJson) =>
    repositorySoupRequests.push(getSoupDataForPackageCollection(packageJson))
  )

  const soupData = await Promise.all(repositorySoupRequests)

  const soupRegister = soupData.join('\n\n')

  core.info(`‚úÖ SOUP data retrieved`)

  // Write SOUP file
  await fs.writeFile(
    soupPath,
    soupRegister,
    { encoding: 'utf8', flag: 'w' },
    (error) => {
      if (error) {
        core.error(error)
        core.setFailed(error)
      } else {
        core.info(`‚úÖ SOUP register written to ${DEFAULT_SOUP_FILENAME}`)
      }
    }
  )

  core.info(`üèÅ SOUP generation finished`)
}

generateSoupRegister()
